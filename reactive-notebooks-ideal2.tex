\section{Reactive Notebooks} 

\noindent {\bf Ideal reactive behavior and functionality.} Co-dependent reactive charts are tremendously useful in this scenario. If the analyst was able to introduce a chart that allows the reader to select a particular range of hours, by directly interacting with it, and use that input to retrieve and plot only the user demographics for this particular range, she could enable the readers (or in this case interactors) to further explore the underlying data without requiring any code literacy from them. Figure \ref{fig:reactive-data-processing} graphically depicts this process (note that the charts that appear side-by-side in Figure \ref{fig:reactive-data-processing} actually appear after the respective coding blocks that generated them in the notebook). The first figure shows the reader of the notebook, selecting a particular time frame; this causes the line chart to zoom in, thus showing only the selected time frame. After the reader performs the selection on the first chart, the subsequent bar chart is also updated thus only showing the age groups of the users that visited the portal during the selected hours. This feature adds useful exploratory capabilities to the notebook, which is of great value to readers. It enables them to further analyze the underlying dataset used by the notebook by simply interacting with the provided visualizations. (For a live demonstration that illustrates how this analysis can be performed using \projname, visit the page: \url{https://czarifis.github.io/vidette-prototype/} )

\eat{
\noindent {\bf This kind of reactive behavior cannot be expressed in traditional interactive notebooks.} It is important to note that this feature cannot be implemented currently in interactive notebooks. Instead, the analyst would have to implement a full blown web application in order to enable non-technical users to interact with visualizations in this way. This requires more time and effort as well as technical expertise with web frameworks that data analysts, might lack. This reactive behavior requires the implementation of actions that have to be invoked when particular mouse events take place on the pixels of the browser that correspond to the visualization. Additionally, such events have to take place in a specific order (mousedown-mousemove-mouseup) for the action to be invoked. The developer of such applications must install observers that listen for such events and then provide the imperative application logic that asynchronously accesses back-end databases to retrieve new data based on the user's selection, process them appropriately and cause mutations to the respective visualizations that depend on them. }

{\bf This kind of reactive behavior cannot be easily expressed in traditional interactive notebooks.} It is important to note that implementing a reactive behavior that can collect user input and use it to access additional data or mutate existing visualizations is extremely arduous currently in interactive notebooks. It is identical to the process developers go through when implementing full blown web applications. It requires more time and effort as well as technical expertise (with third-party web components \cite{Bokeh, plotly} or input widgets \cite{ipywidgets}) that data analysts, might lack. More specifically, describing reactive behavior entails the implementation of actions (functions) that have to be invoked when particular mouse events take place on the pixels of the browser that correspond to the visualization. These actions describe the side-effects that will by applied when such events occur. The developer must install observers that listen for such events and then provide the imperative application logic that asynchronously accesses back-end databases to retrieve new data based on the user's selection, process them appropriately and cause mutations to the visualizations that depend on them. \eat{Most importantly, in some cases the events have to take place in a particular order for the side-effects to make sense (for instance, range selection requires mousedown-mousemove-mouseup). In such scenarios, the developer's logic has to share state between these actions and accordingly modify it when certain events occur. Implementing the code that deals with such cases is extremely error-prone (it is known as callback hell)}

\eat{
\noindent {\bf This kind of reactive behavior cannot be easily expressed in traditional interactive notebooks.} It is important to note that implementing this feature requires familiarity with third-party visualization libraries and widgets that enable collection of user input. Utilizing such libraries resembles the process that application developers have to go through in order to implement a full blown web application

 in order to enable non-technical users to interact with visualizations in this way. This requires more time and effort as well as technical expertise with web frameworks that data analysts, might lack. This reactive behavior requires the implementation of actions that have to be invoked when particular mouse events take place on the pixels of the browser that correspond to the visualization (mousedown-mousemove-mouseup). The developer of such applications must install observers that listen for such events and then provide the imperative application logic that describes the respective side-effects

asynchronously accesses back-end databases to retrieve new data based on the user's selection, process them appropriately and cause mutations to the respective visualizations that depend on them. 


These actions describe side-effects

 This reactive behavior requires the implementation of actions that describe side-effects when particular mouse events take place on the pixels of the browser that correspond to the visualization. Additionally, such events have to take place in a specific order (mousedown-mousemove-mouseup) for the side-effects to occur. This requires the existence of a shared state among these actions, which in itself is very error prone (callback hell). The developer of such applications must install observers that listen for such events and then provide the imperative application logic that asynchronously accesses back-end databases to retrieve new data based on the user's selection, process them appropriately and cause mutations to the respective visualizations that depend on them. This process requires a lot of imperative code to describe the side-effects caused by each event. Additionally, since each action is not only responsible for performing data access, but it's also responsible for generating the derived data that will be used for the visualization 
}
