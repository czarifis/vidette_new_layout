
\section{\projname\ Notebooks}

\projname\ notebooks provide constructs that simplify the process described in the last section. Firstly, \projname\ notebooks support two types of modules that streamline data access and visualizations, namely: \textbf{source wrappers} and \textbf{visual units}. Since these modules come preinstalled with \projname\ notebooks, analysts do not need to install any third-party packages in order to retrieve or visualize data.




\subsubsection*{Source wrappers}

Source wrappers allow the use of source specific languages for querying database systems (for instance SQL can be used to query MySQL and PostgreSQL databases, N1QL for Couchbase etc.). When using a \projname\ notebook, data analysts can directly provide a query on the notebook interface. This query is automatically used by the appropriate source wrapper, that evaluates it, propagates it to the respective data base system and returns the result in JSON format. This result is automatically assigned to a variable which can later be used in subsequent parts of the notebook (as will be described later in this section). Figure \ref{figure:first-running-example:data-retrieval} contains the first query of the analysis that retrieves the dataset required to plot the chart shown in Figure \ref{figure:first-running-example:first-line-chart}. It joins the two tables: $visitors$ and $page\_views$ on the id of the visitor, then groups the result on the $time$ attribute and runs a $count$ aggregate to count the visitors per unit of time. Lastly, it sorts the resulting dataset by time in ascending order and assigns the result into a \projname\ variable. Figure \ref{figure:running-example:query-result} shows the result of this query. Notice that the result has been converted into a JSON array by the respective source wrapper. 

In order for source wrappers to connect to the respective database systems, the data analyst must also provide a configuration file, describing the information required for establishing a connection with each source. Such configuration files are added from the interface of the notebook. Once added, these files are hidden from the UI and encrypted thus diminishing any security concerns. Figure \ref{figure:source-config-file} shows a sample configuration file that is used for accessing a postgres database that contains the data that will by used in our analysis. The configuration file must include the type of the database system, the host name, port and the credentials that will be used for obtaining a connection. Additionally, it must contain the database tables that will be accessible by queries. Only the tables that are explicitly defined in the configuration file will be accessible in the notebook. Once imported, this file is evaluated by the \projname\ engine and the schema of the accessible tables is displayed on the notebook, thus allowing the notebook user to get a glimpse of that information when generating the queries. 





\subsubsection*{Visual Units}
\eat{Once data analysts have obtained the data with the use of source wrappers, they can feed them into visual units in order to generate the respective visualizations. }Visual units are constructs capable of generating fully reactive visualizations, that take advantage of the advanced interactive capabilities of modern browsers. In the eyes of an analyst a visual unit is simply a black box that takes as input a JSON value that describes the state of the visualization. This JSON value is called \emph{unit instance}. The visual unit internally uses the unit instance to invoke the appropriate renderer calls that will generate the expected visualization. A particular instantiation of the unit  can be described as $\gl{<\% unit } U \gl{ \%> } v \gl{ <\% end unit \%>}$, where $U$ the type of the visual unit and $v$ the JSON value corresponding to the unit instance. Figure \ref{figure:running-example:unit-body} shows the unit instance of type \texttt{highcharts}, that is used to generate the visualization shown in Figure \ref{figure:first-running-example:first-line-chart}. The unit instance describes all the information that will be displayed in the visualization (such as the type and title of the chart, the labels on the x axis and so on). Each visual unit, comes with a unit instance schema that describes the format of the unit instance. As the reader interacts with visualizations, she can trigger mutations in the unit instance. For example, if the reader selects a particular area of the chart generated by the unit instance shown in Figure \ref{figure:running-example:unit-body}, the min and max attributes (in lines 6-7) will be updated accordingly.


\begin{figure*}
\centering
%
%
\begin{minipage}[c]{7.5cm}
%
\begin{minipage}[c]{7.5cm}
\begin{code}
\textbf{<\% let} age_groups = 
   SELECT agegroup, count(*) AS total 
   FROM (SELECT CASE
    WHEN age BETWEEN 0 AND 9 THEN '0 to 9'
    WHEN age BETWEEN 10 and 19 THEN '10 to 19'
     ...
    FROM (SELECT * FROM page_views pv join visitors v 
          on pv.v_id = v.vid where time BETWEEN 
          \directive{print}{min_time} and 
          \directive{print}{max_time}) joined_data) jd
   GROUP BY agegroup  
   ORDER BY agegroup ASC \textbf{\%>}
\end{code}
\vspace*{-0.4cm}
\subcaption{Data retrieval}
\label{figure:running-example:age-group-data-retrieval}
\vspace*{0cm}
\end{minipage}

\begin{minipage}[c]{7.5cm}
\begin{code}
age_groups = [
   \{age_group: '0 to 9', total: 12\}, 
   \{age_group: '10 to 19', total: 67\},
   \{age_group: '20 to 29', total: 84\},  ...]
\end{code}
\vspace*{-0.4cm}
\subcaption{Query Result}
\label{figure:running-example:age-group-query-result}
\vspace*{-0.2cm}
\end{minipage}
%
\end{minipage}
\hspace{1cm}
\begin{minipage}[c]{6cm}

\begin{minipage}[c]{8.5cm}
\begin{code}
  \directive{unit}{highcharts}
  \{
    title: 'Visitor information',
    type: 'bar',
    xAxis : \{ 
      labels : [
        \directive{for}{v \textbf{in} age_groups} 
          \directive{print}{v.age_group} 
        \directive{end for}{}]
    \}
    series: [\{
      data: [ \directive{for}{v \textbf{in} age_groups}
          \{
            y  : \directive{print}{v.total}
          \}
        \directive{end for}{} ]
    \}]
  \}
  \directive{end unit}{}
\end{code}
\vspace*{-0.4cm}
\subcaption{Template \texttt{temp\_view}}
\vspace*{0cm}
\label{figure:running-example:age-group-template}
\end{minipage}
\end{minipage}
\vspace*{-0.05cm}
\caption{Template, template instance, and UAS configuration file for the running example}
\vspace*{-0.3cm}
\end{figure*}

\subsubsection*{Templates}
\label{section:template}


\eat{
\begin{figure}[t]
\centering
\scriptsize
\begin{tabular}{B}
\hline
 1  & \gn{template}             & \gp   & \gl{<\% template} \gn{template\_name} (\gn{param\_list}) \gl{\%>}                    \\
    &                           &       & ~~ \gn{let}*                                    \\
    &                           &       & ~~ \gn{unit}
\\
    &                           &       & \gl{<\% end template \%>}                                         \\
 2  & \gn{param\_list}			& \gp   & ( \gn{var\_name} (, \gn{var\_name})* )? 
\\ \hline
 3  & \gn{unit}         & \gp   & \gl{<\% unit} \gn{unit\_class} \gl{\%>}               \\
    &                           &       & ~~ \gn{value}                                         \\
    &                           &       & \gl{<\% end unit \%>}                                 \\
 4  & \gn{value}                & \gp   & \gn{jsonpp\_value} %\text{(see Figure~\ref{figure:bnf-value})} 
\\
 5  &                           & \gd   & \gn{unit}                                     
\\
 6  &                           & \gd   & \gn{print}                                                        \\
 7  &                           & \gd   & \gl{[} \gn{for} \gl{]}                                                                                \\
 8  &                           & \gd   & \gl{<} \gn{for} \gl{>}                                                                                \\
 9  &                           & \gd   & \gn{if}                                                                                 \\
  
 10  &                           & \gd   & \gn{bind}                                                         \\
11  &                           & \gd   & \gl{\{} \gn{event}*                                               \\
    &                           &       & ~~ (\gl{\textquotedbl}\gn{string}\gl{\textquotedbl} 
                                             \gl{:} \gn{value}                                              \\
    &                           &       & ~~ (\gl{,} \gl{\textquotedbl}\gn{string}\gl{\textquotedbl} 
                                             \gl{:} \gn{value})* )? \gl{\}}                                           \\ \hline
12  & \gn{let}                 & \gp   & \gl{<\% let} \gn{var\_name} \gl{=} \gn{expr} \gl{\%>}            
\\
13  & \gn{print}                & \gp   & \gl{<\% print} \gn{expr} \gl{\%>}                                 \\
14  & \gn{for}                  & \gp   & \gl{<\% for} \gn{var\_name} \gl{in} \gn{expr} \gl{\%>}           
\\
    &                           &       & ~~ \gn{let}*                                    \\
    &                           &       & ~~ \gn{value}
\\
    &                           &       & \gl{<\% end for \%>}                                              \\
    
14  & \gn{if}                  & \gp   & \gl{<\% if}  \gn{expr} \gl{\%>}           
\\
    &                           &       & ~~ \gn{value}
\\
 &                           &       & ~~ (\gl{<\% elif}  \gn{expr} \gl{\%>} 
 
\\
 &                           &       & ~~ \gn{value})*    
 \\
 &                           &       & ~~ (\gl{<\% else}  \gl{\%>} 
 
\\
 &                           &       & ~~ \gn{value})?    
\\
    &                           &       & \gl{<\% end if \%>}                                              \\
15  & \gn{bind}                 & \gp   & \gl{<\% bind} \gn{var\_name} = \gn{expr} \gl{\%>}                             \\
16  & \gn{event}                & \gp   & \gl{<\% event} \gn{event\_name} \gn{action\_name} \gl{\%>}        \\
17  & \gn{expr}                 & \gp   & \gn{js\_expression}                                               \\
18  &                           & \gd   & \gn{source\_expression}                                                   \\
19  &                           & \gd   & \gn{json\_path}                                                   \\
\hline
\end{tabular}
\caption{BNF Grammar for Templates}
\label{figure:bnf-template}
\end{figure}
}


Despite the fact that both source wrappers and visual units use the JSON data model, data scientists often need to perform additional computation or simply transformations on JSON data. In order to facilitate this process, without requiring the use of imperative logic, \projname\ provides a declarative template language that operates on JSON data. 



Formally, \emph{Templates} are declarative specifications that can be used to generate JSON variables, parameterized queries or unit instances. The template language supports a set of \emph{template directives}, all of which operate on the JSON data model. Due to lack of space we do not include a formal definition of the grammar, instead we simply describe each of them in detail and provide a concrete example that illustrates their use. 




\noindent {\bf Defining variables.} A template may define variables that are added to the notebook's environment so that they can be used in subsequent statements. The $\gl{<\% let } x \gl{ = } E \gl{ \%>}$ directive defines variable $x$ and assigns to it the result of the expression $E$. $E$ can denote four types of expressions: (a) path navigation on JSON data, (b) invocation of a python function that performs computation by using as input and output JSON values, (c) another subexpression containing directives that report data (defined in the next subsection) or (d) a source-specific language with nested reporting directives (such as a SQL query). For instance, the template shown in Figure \ref{figure:first-running-example:data-retrieval} employs a \gl{let} directive to create a variable \texttt{readings} containing the visitor information that will be displayed in the chart (retrieved from a relational DBMS through an SQL query).

\noindent {\bf Reporting data.} Value assignments and iterations over collections are specified by using the \gl{print} and \gl{for} directives. The $\gl{<\% print } E \gl{ \%>}$ directive evaluates the expression $E$ and returns the result, while the $\gl{<\% for } x \gl{ in } E \gl{ \%> } B \gl{ <\% end for \%>}$ directive specifies that variable $x$ iterates over the result of $E$ and, in each iteration, it instanciates the body $B$ of the \gl{for} loop. Specifically, in Figure \ref{figure:first-running-example:main-template}, in lines 6-8 and 13-17 a \gl{for} directive is used to iterate over the readings retrieved from the database and for each reading, it generates a new JSON value, with the use of the \gl{print} directive. Particularly, in line 7 the template generates a string (the time label), which is added to the labels array (which contains the labels that will appear on the x axis of the chart). In lines 14-16 it generates a JSON object of the form \{y: ...\} and adds it to the data array. The data array in highcharts contains the points that will appear in the chart.

\eat{
\noindent {\bf Collecting data.} In addition to specifying how to compute a template instance, the template's \gl{bind} directive allows the analyst to specify user input collection. Specifically, the $\gl{<\% bind x} \gl{ \%>}$ directive describes a two-way bind that will be created between the part of the unit instance appearing on its left side and to variable $x$. For instance, in Figure \ref{figure:first-running-example:main-template} in lines 10-11 we create a two-way binding between the min and max boundaries of the chart and the min and max values of the time labels that have been retrieved (namely min\_time and max\_time). While the user interacts with chart he can select a particular region in the chart which in turn updates the values $min\_time$ and $max\_time$. This event invokes an internal propagation algorithm (which will be described in the next section) which triggers the revaluation of the \projname\ statements that use the values $min\_time$ and $max\_time$ in other parts of the notebook.
}





\noindent {\bf Collecting data.} The template's \gl{bind} directive allows the analyst to specify user input collection. Specifically, the $\gl{<\% bind x} \gl{ \%>}$ directive describes a two-way binding between the part of the unit instance appearing on the left side of the directive and the variable $x$. Once the reader interacts with the generated visualization and causes mutations to the underlying unit instance, these mutations will be propagated to the respective bound variables. For instance, in Figure \ref{figure:first-running-example:main-template} in lines 9-10 we create a two-way binding between the min and max boundaries of the chart and the min and max values of the time labels that have been received from the database (namely min\_time and max\_time). As the reader interacts with the generated chart she can select a particular time frame by dragging and dropping the mouse over a region. This action updates the min and max attributes of the unit instance which in turn updates the values $min\_time$ and $max\_time$. 

\eat{
This event invokes an internal propagation algorithm (which will be described in the next section)  triggers the revaluation of the \projname\ statements that use the values $min\_time$ and $max\_time$ in other parts of the notebook.

For instance, the template shown in Figure \ref{figure:first-running-example:main-template} contains two variables, namely $min\_time$ and $max\_time$, which are bound to the $min$ and $max$ unit instance attributes respectively. These variables are later used in the parameterized query shown in Figure \ref{figure:running-example:age-group-data-retrieval} which retrieves information about the users that visited the website in the time-frame specified by $min\_time$ and $max\_time$, groups the result in age groups and sums up the visits made by each age group. Figure \ref{figure:running-example:age-group-query-result}, contains the result of that query. This result is assigned to variable $age\_groups$ which is then used to produce the bar chart appearing in Figure \costas{add Figure} (the template shown in Figure \ref{figure:running-example:age-group-template} shows the template that created that chart)
}
\subsubsection*{Internal Data Model \&  Propagation Algorithm}
\label{section:change-propagation-datamodel}




Once a set of bound variables is mutated by a visual unit as a result of reader interaction, \projname\ is responsible for reflecting these changes to all other parts of the notebook that depend on those variables. For instance, in Figure \ref{figure:running-example:age-group-data-retrieval} we show a parameterized query that collects all users that visited the website in the time-frame specified by $min\_time$ and $max\_time$, then categorizes them into age groups and lastly counts the users that correspond to each age group. The result of this query is assigned to the variable $age\_groups$ (Figure \ref{figure:running-example:age-group-query-result} shows the contents of this variable). The variable $age\_groups$ is then used in the template shown in Figure \ref{figure:running-example:age-group-template} (lines 7-9 and 12-16) to produce the bar chart appearing in Figure \ref{figure:first-running-example:first-bar-chart}. In this scenario, if the reader's interaction with the chart shown in Figure \ref{figure:first-running-example:first-line-chart}, caused the mutation of variables $min\_time$ and $max\_time$, then \projname\ must trigger a chain reaction that causes the reevaluation of both the query and the following visualization in order to reflect the changes. We will now describe this process.



% which categorizes the users that visited the website in the time-frame specified by $min\_time$ and $max\_time$ by age groups and then sums up the visits made by each age group. Figure \ref{figure:running-example:age-group-query-result}, contains the result of that query. This result is then assigned to variable $age\_groups$ which is then used to produce the bar chart appearing in Figure \ref{figure:first-running-example:first-bar-chart} (the template shown in Figure \ref{figure:running-example:age-group-template} shows the template that created that chart)


\eat{
the template shown in Figure \ref{figure:first-running-example:main-template} contains two variables, namely $min\_time$ and $max\_time$, which are bound to the $min$ and $max$ unit instance attributes respectively. These variables are later used in the parameterized query shown in Figure \ref{figure:running-example:age-group-data-retrieval} which retrieves information about the users that visited the website in the time-frame specified by $min\_time$ and $max\_time$, groups the result in age groups and sums up the visits made by each age group. Figure \ref{figure:running-example:age-group-query-result}, contains the result of that query. This result is assigned to variable $age\_groups$ which is then used to produce the bar chart appearing in Figure \costas{add Figure} (the template shown in Figure \ref{figure:running-example:age-group-template} shows the template that created that chart)
}



\eat{Since, as explained above, \projname\ variables are represented using JSON, changes to either of them are represented as diffs.}
\noindent{\bf Internal Data Model - Diffs} \\ Once a variable is mutated by a unit, a diff is also generated to describe this mutation. A \emph{diff} is the internal data model that is shared between visual units and the change propagation algorithm, this data model is hidden from data analysts and notebook readers. A diff that targets a JSON value is of the form $\diff{}{}{\pp{p}}$, where $\pp{p}$ is the path to the element that is being modified. 

\eat{The first token, $f$ of that path $\pp{p}$ denotes the variable that is being mutated; if the diff contains information about mutations on particular attributes or elements of the variable, then $f$ is followed by more tokens. Specifically, in order to describe a mutation on an individual attribute $k$ of a JSON value identified by path $p$ we use the notation $p.k$ and in order to describe the $i$-th element of the array targeted by a path $p$ we use the notation $p[k]$.}

\noindent{\bf Change Propagation Algorithm.}\\
Once a diff is generated for each mutated variable \projname\ invokes the change propagation algorithm. Algorithm \ref{algo:change-propagation-algorithm2} summarizes this change propagation algorithm. The algorithm takes as input a set of diffs, and invokes the reevaluation of all statements that depend on the targeted variables. Specifically, it iterates over each statement of each coding snippet that appears in the notebook (as shown in line 2) and performs the following checks:

\begin{compactitem}

\item If the statement defines a new variable $x$ (line 3), then the algorithm visits every sub-expression of the \gl{let} directive and checks if it is targeted by any diff in D (line 4). If there is, the change propagation algorithm causes the reevaluation of the $\gl{let}$ statement (line 5), updates the notebook environment with the new value of x (line 6) and lastly constructs a new diff that targets x (line 7)

\item If the statement constructs a visualization using a visual unit of type U with body B (line 8), then the algorithm visits every sub-expression in body B and checks if it is targeted by any diff in D (line 9). If there is, the change propagation algorithm causes the reevaluation of the entire body B, thus generating the unit instance r and then reinvokes the unit U with new unit instance (line 10).



\end{compactitem}

\eat{

\begin{figure*}
\centering
%
%
\begin{minipage}[c]{7.5cm}
%
\begin{minipage}[c]{7.5cm}
\begin{code}
\textbf{<\% let} age_groups = 
   SELECT agegroup, count(*) AS total 
   FROM (SELECT CASE
    WHEN age BETWEEN 0 AND 9 THEN '0 to 9'
    WHEN age BETWEEN 10 and 19 THEN '10 to 19'
     ...
    FROM (SELECT * FROM page_views pv join visitors v 
          on pv.v_id = v.vid where time BETWEEN 
          \directive{print}{min_time} and 
          \directive{print}{max_time}) joined_data) jd
   GROUP BY agegroup  
   ORDER BY agegroup ASC \textbf{\%>}
\end{code}
\vspace*{-0.4cm}
\subcaption{Data retrieval}
\label{figure:running-example:age-group-data-retrieval}
\vspace*{0cm}
\end{minipage}

\begin{minipage}[c]{7.5cm}
\begin{code}
age_groups = [
   \{age_group: '0 to 9', total: 12\}, 
   \{age_group: '10 to 19', total: 67\},
   \{age_group: '20 to 29', total: 84\},  ...]
\end{code}
\vspace*{-0.4cm}
\subcaption{Query Result}
\label{figure:running-example:age-group-query-result}
\vspace*{-0.2cm}
\end{minipage}
%
\end{minipage}
\hspace{1cm}
\begin{minipage}[c]{6cm}

\begin{minipage}[c]{8.5cm}
\begin{code}
  \directive{unit}{highcharts}
  \{
    title: 'Visitor information',
    xAxis : \{ 
      labels : [
        \directive{for}{v \textbf{in} age_groups} 
          \directive{print}{v.age_group} 
        \directive{end for}{}]
    \}
    series: [\{
      data: [ \directive{for}{v \textbf{in} age_groups}
          \{
            y  : \directive{print}{v.total}
          \}
        \directive{end for}{} ]
    \}]
  \}
  \directive{end unit}{}
\end{code}
\vspace*{-0.4cm}
\subcaption{Template \texttt{temp\_view}}
\vspace*{0cm}
\label{figure:running-example:age-group-template}
\end{minipage}
\end{minipage}
\vspace*{-0.05cm}
\caption{Template, template instance, and UAS configuration file for the running example}
\vspace*{-0.3cm}
\end{figure*}
}


\eat{
\begin{itemize}
\item First, if the statement defines a new variable $x$ by using a $\gl{let}$ directive, and the expression of $\gl{let}$ contains at least one reporting directive (either a $\gl{for}$ or a $\gl{print}$), then the algorithm checks whether there is a diff that targets any of the expressions of the reporting directives. If there is, the change propagation algorithm causes the reevaluation of the $\gl{let}$ statement, updates the notebook environment with the new value of x and constructs a new diff that targets x
\item 2 if the statement defines a new variable $x$ by using a $\gl{let}$ directive, and the expression of $\gl{let}$ contains at least one for $\gl{for}$ the body of which contains some , then the algorithm checks whether there is a diff that targets any of the expressions of the reporting directives. If there is, the change propagation algorithm causes the reevaluation of the $\gl{let}$ statement, updates the notebook environment with the new value of x and constructs a new diff that targets x
\item 3

\end{itemize}
}

\begin{algorithm}[t!]
    \SetKwProg{Function}{function}{}{}
    \SetKwFunction{changepropagation}{change-propagation}
    \SetKwFunction{IVMPath}{IVMPath}
    \SetKwFunction{prefixDiffs}{prefixDiffs}
    \SetKwFunction{navigate}{navigate}
    \SetKwFunction{keysWithin}{keysWithin}
    \SetKwFunction{instantiateTemplate}{instantiateTemplate}
    \SetKwFunction{instantiateVmPayload}{instantiateVmPayload}
    \SetKwFunction{instantiateForLoopVmPayload}{instantiateForLoopVmPayload}
    \Function{\changepropagation{Notebook $N$, Environment $env$, Set of Input Diffs $D$}}{
    	\For {\textbf{each} statement s in each coding snippet of N}{
	    		 \uIf  {s is $\gl{<\% let } x \gl{ = } E \gl{ \%>}$ } {
	    		  \uIf  {There is $\Delta^{}(t) \in D$ with $t$ that targets any subexpression of E} {
	    		    Reevaluate $E$ and assign result $r$ to $x$\;
	    		    Update $env$ with new value of $x$\;
	    		    Construct $\Delta^{}(x)$ and add it to D\;
	    		 }
    		 }
			 \uElseIf  {s is $\gl{<\%unit } U \gl{\%> } B \gl{ <\%end unit\%>}$ } {
			 	\uIf  {There is $\Delta^{}(t) \in D$ with $t$ that that targets any subexpression of B} {
			  		Reevaluate $B$ and invoke unit U with result $r$ \;
			 	}
             }    
        }
        
    }
\caption{Change Propagation Algorithm}
\label{algo:change-propagation-algorithm2}
\end{algorithm} 


%\input{interactivity-algorithm}


\eat{

This template language allows the invocation of functions. Regardless of whether these functions are defined by users or by third-party packages they must operate on the JSON data model, in order to be used in a template.

Source wrappers produce and visual units consume JSON. Since both these constructs use the JSON data model, no data model transformations are required by the analyst. This minimizes the amount of plumbing code required for generating an analysis. For cases when the data analyst wishes to perform some additional computation or perform data transformations, \projname\ also supports a declarative template language that operates on JSON data. This template language also allows the invocation of functions. Regardless of whether these functions are defined by users or by third-party packages they must operate on the JSON data model, in order to be used in a template.

\emph{Templates} are declarative specifications that can be used to generate \projname\ variables or unit instances. The template language supports a set of \emph{template directives}, all of which operate on the JSON datamodel. These directives are used to describe computation, define variables and set up data collection. Due to lack of space we do not include a figure containing a formal BNF grammar for the template language, instead we simply describe each of them in detail and provide a concrete example that illustrates their use. 




\noindent {\bf Defining variables.} A template may define variables that are added to the notebook's environment so that they can be used in subsequent computation. The $\gl{<\% let } x \gl{ = } E \gl{ \%>}$ directive defines variable $x$ and assigns to it the result of the expression $E$. $E$ can denote three types of expressions: path navigation on JSON data, invocation of a python function that performs computation by using as input and output JSON values or a source-specific language (such as a SQL query). For instance, the template shown in Figure \ref{figure:first-running-example:data-retrieval} employs a \gl{let} directive to create a variable \texttt{readings} containing the visitor information that will be displayed in the chart (retrieved from a relational DBMS through an SQL query).

\noindent {\bf Reporting data.} Value assignments and iterations over collections are specified by using the \gl{print} and \gl{for} directives. The $\gl{<\% print } E \gl{ \%>}$ directive evaluates the expression $E$ and returns the result, while the $\gl{<\% for } x \gl{ in } E \gl{ \%> } B \gl{ <\% end for \%>}$ directive specifies that variable $x$ iterates over the result of $E$ and, in each iteration, it instanciates the body $B$ of the \gl{for} loop. In Figure \ref{figure:first-running-example:main-template}, in lines 7-9 and 14-18 a \gl{for} directive is used to iterate over the readings retrieved from the database and for each reading, it generates a new JSON value, with the use of the \gl{print} directive. Particularly, in line 8 the template generates a string (the time label), which is added to the labels array (which contains the labels that will appear on the x axis of the chart). In lines 15-17 it generates a JSON object of the form \{y: ...\} and adds it to the data array. The data array in highcharts contains the points that will appear in the chart.

\noindent {\bf Collecting data.} In addition to specifying how to compute a template instance, the template's \gl{bind} directive allows the analyst to specify user input collection. Specifically, the $\gl{<\% bind x} \gl{ \%>}$ directive describes a two-way bind that will be created between the part of the unit instance appearing on its left side and to variable $x$. For instance, in Figure \ref{figure:first-running-example:main-template} in lines 10-11 we create a two-way binding between the min and max boundaries of the chart and the min and max values of the time labels that have been retrieved (namely min\_time and max\_time). While the user interacts with chart he can select a particular region in the chart which in turn updates the values $min\_time$ and $max\_time$. This event invokes an internal propagation algorithm (which will be described in the next section) which triggers the revaluation of the \projname\ statements that use the values $min\_time$ and $max\_time$ in other parts of the notebook.



that take as input JSON objects (in a predefined format) and generate visualizations on the notebook interface. By not requiring any low level imperative code for this task 

\label{section:visual Units}

\noindent To shield analysts from the low level coding required to generate visualizations, \projname\ abstracts out each visual component as a \projname\ \emph{visual unit} (or simply \emph{unit}). In the eyes of the analyst a visual unit is simply a black box that takes as input a JSON value that describes the visualization, namely, unit instance. The visual unit internally uses the unit instance to invoke the appropriate renderer calls that will generate the expected visualization. As such a particular instantiation of the unit  can be described as $\gl{<\% unit } U \gl{ \%> } v \gl{ <\% end unit \%>}$, where $U$ the type of the visual unit and $v$ the JSON value corresponding to the input of the unit. 


For instance, Figure \ref{figure:running-example:unit-body} shows a unit instance of type \texttt{highcharts}. The unit instance describes all the information that will be displayed in the visualization (such as the title of the chart, the labels on the x axis and so on). Each visual unit, comes with a unit instance schema that describes the format of the unit instance.




In order for source wrappers to connect to the respective database systems, the data analyst must provide a configuration file, describing the information required for establishing a connection with each source. Such configuration files are added by interacting directly with the notebook interface, therefore data analysts do not have to use a command line during setup. Once added, these files are hidden from the UI and encrypted thus diminishing any security concerns. Lastly, visual units are constructs that take as input JSON objects (in a predefined format) and generate visualizations on the notebook interface. 


Source wrappers produce and visual units consume JSON. Since both these constructs use the JSON data model, no data model transformations are required by the analyst. This minimizes the amount of plumbing code required for generating an analysis. For cases when the data analyst wishes to perform some additional computation or perform data transformations, \projname\ also supports a declarative template language that operates on JSON data. This template language also allows the invocation of functions. Regardless of whether these functions are defined by users or by third-party packages they must operate on the JSON data model, in order to be used in a template.

This language also allows data analysts tp describe reactive behavior. Specifically, by binding individual variables to certain parts of the visual unit, data analysts can collect information which can later be used in other parts of the notebook. By doing so, analysts can describe computation that depends on the reader's input. \projname's propagation algorithm, identifies statements that depend on such libraries and triggers their evaluation. This process leads to truly interactive notebooks, that react to the reader's input, thus enhancing the exploratory capabilities of traditional notebooks.
}
\eat{
Source wrappers require the instantiation of a configuration file, that describes the information required for establishing a connection with each source. Such configuration files are added by data analysts by interacting directly with the notebook interface. Once added, these files are hidden from the UI and encrypted thus diminishing any security concerns. Lastly, visual units are constructs that take as input JSON objects (in a predefined format) and generate visualizations on the notebook interface. 


Most importantly, source wrappers and visual units, both use the same data model JSON, so no data model transformations are required for retrieving and visualizing data. For cases when the data analyst wishes to perform some data transformations, \projname\ also supports a declarative template language.


Once a source wrapper receives a query, it propagates it to the respective database system, and then parses and returns the result in JSON format. Source wrappers require the instantiation of a configuration file, that describes the information required for establishing a connection with each source. Such configuration files are added by data analysts by interacting directly with the notebook interface. Once added, these files are hidden from the UI and encrypted thus diminishing any security concerns. Lastly, visual units are constructs that take as input JSON objects (in a predefined format) and generate visualizations on the notebook interface. 

Both source wrappers and visual units come pre-installed and can be used directly on the notebook without the installation of any additional packages. Additionally, since no method calls are required for accessing and visualizing data, the analyst does not have to read long documentation files before using them. Most importantly, source wrappers and visual units, both use the same data model JSON, so no data model transformations are required for retrieving and visualizing data. For cases when the data analyst wishes to perform some data transformations, \projname\ also supports a declarative template language.
}

\eat{
interactive chart implementation using imperative languages is not a trivial task and possibly beyond the coding skill set of an average data analyst. Such a task requires advanced coding skills and implementation of event listeners to capture the user's mouse input and asynchronously trigger execution of other functions that will update data and re-draw the second figure. As we show later in Section ??, the {\projname} framework is equipped with modules that can take care of the heavy work, while the analyst only needs to define ``bound'' (linked) variables.


Finally, 


plot a line chart of access count Vs timestamp, as well as a bar chart of access count Vs age groups, and (c) be able to select a time range from the line chart using mouse input and automatically filter and display data in the second plot to present age-group-based activity within the selected time frame. 


The data analyst can access historic data about the user base by directly querying the data base system. Table \ref{tab:schema} shows the database schema. The analyst's first task is to retrieve the data via database queries, join the two tables based on the visitor id (``vid'') key and group by (1) ``time'' and (2) ``age'' to prepare the data for the two plots.

Installing packages, transferring data and connecting with database systems requires technical knowledge that often exceeds the skill-set of a typical data scientist. Lastly, while such notebooks support the generation of visualizations with the use of the appropriate library



Throughout this paper, we present {\projname} via an example data analysis: We assume a scenario where a data analyst must (a) retrieve  website access information from a database, (b) plot a line chart of access count Vs timestamp, as well as a bar chart of access count Vs age groups, and (c) be able to select a time range from the line chart using mouse input and automatically filter and display data in the second plot to present age-group-based activity within the selected time frame. 

For our walkthrough example, we assume a Jupyter server where the analysts develop their notebooks and a different database server where data is stored. Table \ref{tab:schema} shows how our databases are organized. The analyst's first task is to retrieve the data via database queries, join the two tables based on the visitor id (``vid'') key and group by (1) ``time'' and (2) ``age'' to prepare the data for the two plots.

During the visualization stage, the analyst implements two ``linked'' plots in such a way that a range selection in the first plot \textit{automatically} (without re-executing code in the notebook) filters the data presented in the second plot. Figure \ref{fig:vision} illustrates the expected chart behavior. A time-frame selection in the first chart (10:00AM - 1:00PM) causes the second chart to only plot those accesses that occurred during the selected interval. 

It is important to note that this interactive chart implementation using imperative languages is not a trivial task and possibly beyond the coding skill set of an average data analyst. Such a task requires advanced coding skills and implementation of event listeners to capture the user's mouse input and asynchronously trigger execution of other functions that will update data and re-draw the second figure. As we show later in Section ??, the {\projname} framework is equipped with modules that can take care of the heavy work, while the analyst only needs to define ``bound'' (linked) variables.
}