\section{Introduction}
\label{section:introduction}

\noindent \textbf{Contributions} We describe the following contributions of \projname:
\begin{compact_item}

%
\remark{We spend 2 full pages on the introduction (with comments but still an issue), which is not viable in a 6-page paper. On top of running out of space, it makes the section feel way too long and boring. }

\remark{We also waste too much space using these lists. We either change the formatting to start from the beginning of the line, or figure out a different way to write.}

\remark{My suggestion is: Move some of the abstract text here and present the list of contributions with minimal text and as little detail as possible. When we then describe the architecture/design/concept, we refer back to how it affects these challenges.}

\item \textit{Declarative Semantics:} We present a formal declarative MVVM semantics for \projname. To the best of our knowledge, this is the first formal presentation of MVVM declarative semantics by an MVVM framework. \yannis{What extra do we offer in light of CIDR11 to the semantics?} 
\remark{``MVVM'' used without previous declaration}

\costas{Fundamentally, they are both diff driven application frameworks... Some differences are that the CIDR11 and SIGMOD10 version: 1.the template language was written in XML which was more verbose and therefore needed more effort to be written (more characters per line and more total lines of code for the same template instance). 2.Additionally, since template functions were not supported, the app developer often had to inline complex SQL++ queries in the template to ``massage" the data appropriately. 3. Delta functions were not supported. Overall templates appeared more convoluted compared to the current version and therefore they were harder to follow. For more differences check respective file in Notes folder (at the root of the repo)} \yannis{A large difference between CIDR11 and current work is the aim to easily interface with JavaScript. This is behind the functions in the template language, the interfacing of JavaScript components, the JavaScript actions and (the missing) easy programming model for accessing JavaScript data (the latter can stay for journal or OOPSLA)} Hence, the declarative semantics of \projname\ can also serve as an introduction to the semantics of MVVM at large, and to the semantics of \angular\ and other MVVM frameworks, after one accounts for their limitations.
%
\item \textit{Expressive Template Language:} While we draw from prior database research work, which treats the page as a database view, the template language goes beyond SQL query and view definitions in both style and fundamental expressiveness \yannis{Good point for a journal publication but on VLDB suffers from CIDR comparisons. The reason behind the higher expressiveness is new.}: It is a mixture of query language and web templating language that works on ordered data (arrays) and semi-structured data (JSON) \costas{JSON encompasses the concept of arrays/ ordered data}and is expressive enough to cover many common transformations without requiring the use of additional imperative JavaScript code. Notably, it is more expressive than the language of \angular, due to reasons pertaining to differences in their incremental rendering algorithms. \yannis{Cannot be quickly backed up by the example. Two nested loops may be hard but a for/if combo is doable.} \costas{How would it be backed up by example? We would have to introduce Angular and \projname\ templates in the intro, wouldn't we?} Furthermore, besides visualization, the templates can also input data and catch events/activate actions \costas{actions have not been defined}, as a complete web application development framework should do.

%
\item \textit{Incremental Rendering:} The incremental rendering problem has similarities to Incremental View Maintenance (IVM) but also poses distinct new challenges due to (1) template language features that have not received attention by the database community, and (2) unlike IVM whose goal is to update a target materialized view, the incremental rendering algorithm is a \textit{diff propagation} algorithm that results into a sequence of calls to the rendering methods of (the usually 3rd party) components. \yannis{A diff and its resulting rendering method call should have been demonstrated in the context of the example.} Pertaining to Item~(1) \projname\ solves the following diff propagation problems:
\begin{compact_enum}
\item \textit{Handling Arrays:} Arrays are prime citizens of the data model. Therefore we reconsidered what is the appropriate language for describing diffs, so that diffs on arrays are included. \costas{What do we mean when we say ``language" for describing diffs}\yannis{Current example has no motivation for insertion in the middle of array, which is where problems happen.}Second we developed algorithms for propagating such diffs.   
%


\item \textit{Black-box functions in Template:}\yannis{no example of a function either. It need not be the first example but I think there is just no example.} In the rare cases where the out-of-the-box expresiveness of the template language is not enough, the developer can include Javascript function invocations in her template. \projname\ offers a pay-as-you-go approach to the efficient diff propagation through JavaScript functions that may be part of the template: The developer may provide nothing (but the function itself), in which case the diff propagation algorithm will still work but may be slow\costas{Let's avoid the word slow, let's just say it wouldn't work ``incrementally", which is the more efficient.}, as it will be re-evaluating the function. Alternately, the developer may provide one or more diff management functions, which are suggested to her by \projname\ and lead to more efficient diff propagation. \costas{We should also mention that we provide some of these functions out-of-the-box (e.g sortby, groupby etc...)}\yannis{IMPORTANT: we need to discuss how this differs from angular's pay-as-you-go} \costas{Angular does not provide something similar to \projname's delta functions, so there's nothing to pay as you go}
%\costas{The IVM algorithm will be fast, the function re-evaluation may be slow (We should make it clear to the reader that the bottleneck isn't the template IVM algorithm but the user defined function...). That's why we enable the function developer to provide auxiliary delta functions that update the logical page more efficiently. }
%

\item \textit{Loops in Templates} \projname\ provides diff propagation over loop structures.  \costas{Why is that a big deal? This bullet doesn't illustrate why that's challenging or interesting...}\yannis{would be far more convincing with fors and ifs}

% 
\end{compact_enum}
%
The \projname\ incremental rendering also solves the following problems pertaining to its need to translate diffs into rendering method calls. \yannis{as said above, problems should have memorable names and do not repeat the whole description continously} \costas{refer to dictionary spreadsheet} \url{https://docs.google.com/spreadsheets/d/1pn6EPZUnz\_3Tc3e7FnveRxQXcs2uRqD0znERjI0-g0o/edit#gid=0}
\begin{compact_enum}

\item \textit{Easy wrapping of 3rd party components} A novel triggering algorithm enables the easy and pay-as-you-go wrapping of Javascript visualization rendering methods. In particular, the developer in charge of wrapping a visualization component is only tasked with specifying the single diff that a rendering method handles. \costas{This sentence doesn't make sense: ``(The developer specifies the) single diff that a rendering method handles". The developer does not specify diffs, he specifies renderer wrappers and diff signatures (refer to dictionary). The number of renderer wrappers he needs to specify is anything between two (construct-destruct) and the total number of renderers supported by the visualization library} \yannis{Needs example. Recall, earlier we introduced a diff and a corresponding renderer. Here we should change the assumption on renderer or the diff so that we can show simulation.}Therefore the size of the specification \costas{what specification?}is proportional to the number of rendering methods she wishes to wrap, as opposed to the number of the possible kinds of diffs, which is typically far larger. \costas{the latter number is: supported-diff opcodes X potential targets in unit instance} \yannis{tell the number that shows how many diffs exist in our example. You don't have to substantiate yet why so many. The substantiation will come much later once we have shown the unit's "schema" and have explained how many kinds of diff exist.
The most impressive introductions say "without my technique it would be N and with my technique it is M that is an order of magnitude below"} \costas{I don't follow. Why do we need to specify the number of possible diffs. When reading this section it feels like we're comparing our system with a system similar to ours that does not support simulation. Angular does not work with diffs, so this is somewhat pointless.} When a diff is produced that does not correspond directly to a rendering method, \projname\ discovers how to indirectly support it by \textit{simulating} the missing rendering method with existing wrapped rendering methods. \costas{we should add something like: ``This automation significantly simplifies the process of unit wrapping. Since competing frameworks do not provide a similar feature, unit developers are often required to manually perform it manually. This negatively impacts both the amount of time that needs to be spent in unit wrapping and the amount of lines of code that need to be written"}Lines-of-code experiments show the advantage of \projname\ in 3rd party wrapping productivity.

\eat{
\costas{The reasons why Angular directives need more lines are:
Actually the problem, arises when two renderers exist, one at a deeper level then the other. In such cases, Angular directive developers have to install a deep watcher at the higher level and manually compare the parts that correspond to more ``specific" renderers, to identify what changed. This happens to avoid the invocation of multiple renderers, which would be a direct result of}
}
%
\item \textit{Managing Direct Updates and Provenance Heterogeneity} \projname\ treats update diffs as first-class citizens, as opposed to simulating updates by insert-delete combinations. \costas{Not sure why we mention this, Angular directives don't need to simulate updates diffs with insert-delete diffs. Is this something that other IVM algorithms do not support?} This feature leads to higher performance and also superior UI behavior, when the visualization components provide update renderer methods. It also creates a need for keeping track of the provenance of each part of the visualization, so that it can be identified and updated. Notice that provenance has to be converted into terms that the 3rd party component understands, creating a need for special conversion data structures and algorithms. \yannis{Needs support of the example, both on the update and on the provenance. (The current example is an insertion and does not have any provenance problem.)}
\end{compact_enum}
%
\item \textit{Superior performance over other MVVM frameworks:} A net effect of the algorithms is that the client-side incremental rendering algorithm achieves better Big-O algorithmic complexity than the incremental rendering algorithm of \angular\ and also ouperforms it in the presented experiments.
%
\end{compact_item}

{\bf Paper Outline.} \yannisk{Revise after the sections have been finalized} The paper is structured as follows: In Section \ref{section:programming-model} we explain the structure of a \projname\ application as seen by an application developer. Section \ref{section:architecture} describes \projname's internal architecture, while Sections \ref{section:template-ivm}-\ref{section:visual-ivm} describe the incremental view maintenance algorithms that power the framework. Section \ref{section:experiments} compares the performance and productivity gains of the proposed system against the state of the art. Finally, Sections \ref{section:related-work} and \ref{section:conclusion} discuss related work and conclude the paper, respectively.